#!/usr/bin/ruby
# encoding: UTF-8
#
# Program to receive backups and run rsync in receive mode.  Must check that
# user as authorised by SSH is allowed to access particular directory.

$LOAD_PATH << '/usr/lib/byteback'

require 'trollop'
require 'byteback'
require 'byteback/restore'

include Byteback::Log

if ENV['SSH_ORIGINAL_COMMAND']
  ARGV.concat(ENV['SSH_ORIGINAL_COMMAND'].split(' '))
end

byteback_host = ENV['BYTEBACK_HOST']
fatal('BYTEBACK_HOST environment not set') unless byteback_host

byteback_root = ENV['HOME'] + '/' + ENV['BYTEBACK_HOST']
fatal("#{byteback_root} does not exist") unless File.directory?(byteback_root)

#
# Calling byteback-restore really needs rsync to restore the files.
#
if (ARGV[0] == 'byteback-restore')
  #
  # Ignore the first arg
  #
  ARGV.shift

  args = ["rsync"]
  snapshot = nil
  verbose = false
  all = false

  #
  # Mangle the arguments, and pull out any that are not-rsync compatible.
  #
  while(arg = ARGV.shift)
    case arg
      when "."
        break
      when /^-([^-]*v[^-]*|-verbose)$/
        verbose = true
        args << arg
      when "--snapshot"
        snapshot = ARGV.shift
      when "--all"
        all = true
      else
        args << arg
    end
  end

  # Always exclude the current directory, because it can change the
  # ownership at the restorers end.
  args << "--exclude=."


  restore = Byteback::Restore.new(byteback_root)
  restore.snapshot = snapshot if snapshot
  restore.find(Byteback::Restore.decode_args(ARGV))

  Dir.chdir(byteback_host)

  restore.results.each do |r|
    args <<  File.join(".", r.snapshot, r.path)
  end

  info(args.join(" "))
  exec(*args)

elsif ARGV[0] == 'rsync'
  ARGV[-1] = "#{byteback_root}/current"
  exec(*ARGV)

elsif ARGV[0] == 'byteback-snapshot'
  ARGV.concat(['--root', "#{byteback_root}"])
  exec(*ARGV)

elsif ARGV[0] == "restore"
  puts "** Your byteback package needs to be updated.  Please update and try again."
  exit(1)

end

opts = Trollop.options do
  opt :verbose, 'Print diagnostics'
  opt :ping, 'Check connection parameters and exit'
  opt :list, 'Show backed up files matching the given pattern'
  opt :list_all, 'Show all stored versions of a file'
  opt :snapshot, 'Show backed up files in a certain snapshot.', :default => '*'
  opt :restore, 'Perform a restoration operation', :type => :string
  opt :complete, 'Mark current backup as complete'
end

error('Please only choose one mode') if opts[:ping] && opts[:complete]
if opts[:complete]
  system('byteback-snapshot', '--root', byteback_root)
elsif opts[:list]
  args = Byteback::Restore.decode_args(ARGV[1..-1])

  restore = Byteback::Restore.new(byteback_root)
  restore.snapshot = opts[:snapshot]
  restore.find(args, :all => opts[:list_all], :verbose => opts[:verbose])

  if restore.results.empty?
    puts "** Sorry.  There were no files matching:"
    puts "--> "+args.join("\n--> ")
  else
    puts restore.list
  end
  exit(0)
elsif opts[:ping]
  exit 0
else
  STDERR.print "byteback-receive failed\n"
  exit 9
end
